<?php/* * @author Shukurullo Odilov * @link telegram: https://t.me/yii2_dasturchi * @date 24.07.2021, 10:06 */namespace soft\db;use Yii;use soft\widget\kartik\DateRangePicker;use yii\caching\TagDependency;use yii\db\ActiveQuery as YiiActiveQuery;use yii\db\Expression;use yii\db\ExpressionInterface;/** * This is the query class for ActiveRecord * * @property string $tableName */class ActiveQuery extends YiiActiveQuery{    private $_tableName;    use MultilingualQueryTrait;    /**     * @return string     */    public function getTableName()    {        if ($this->_tableName == null) {            /* @var $modelClass ActiveRecord */            $modelClass = $this->modelClass;            $this->tableName = $modelClass::tableName();        }        return $this->_tableName;    }    /**     * @param string $tableName     */    public function setTableName($tableName)    {        $this->_tableName = $tableName;    }    /**     * Generates attribute name with table name.     * @param $attribute     * @return string     */    public function generateAttributeName($attribute)    {        return $this->tableName . '.' . $attribute;    }    /**     * @param string $attribute     * @param mixed $value     * @param bool $isEqual     * @return $this     */    public function equal($attribute, $value, $isEqual = true)    {        if ($isEqual) {            $this->andWhere([$attribute => $value]);        } else {            $this->andWhere(['!=', $attribute, $value]);        }        return $this;    }    /**     * @param $attribute string     * @param $value mixed     * @return $this     */    public function notEqual($attribute, $value)    {        $this->equal($attribute, $value, false);        return $this;    }    /**     * @param $attribute string|null     * @param bool $isActive     * @return $this     */    public function active(bool $isActive = true, string $attribute = null)    {        if ($attribute == null) {            $attribute = $this->generateAttributeName('status');        }        $this->equal($attribute, ActiveRecord::STATUS_ACTIVE, $isActive);        return $this;    }    /**     * @param int $limit     * @param string $attribute     * @return $this     */    public function latest(int $limit = 0, string $attribute = 'created_at'): ActiveQuery    {        $this->desc($this->generateAttributeName($attribute));        if ($limit > 0) {            $this->limit($limit);        }        return $this;    }    /**     * @param string|int $id     * @param bool $isEqual     * @param string $attribute     * @return $this     */    public function id($id, bool $isEqual = true, $attribute = null)    {        if ($attribute == null) {            $attribute = $this->generateAttributeName('id');        }        $this->equal($attribute, $id, $isEqual);        return $this;    }    /**     * @param string|int $id     * @param string|null $attribute     * @return $this     */    public function notId($id, string $attribute = null)    {        $this->id($id, false, $attribute);        return $this;    }    /**     * @param string $slug     * @param string $attribute     * @return $this     */    public function slug($slug, string $attribute = 'slug')    {        return $this->equal($attribute, $slug);    }    /**     * @param int|ExpressionInterface|null $limit     * @return $this     */    public function random($limit = null)    {        $this->orderBy(new Expression('rand()'))->limit($limit);        return $this;    }    /**     * Removes given relation from query.     * @param string $relation     * @return $this     */    public function without(string $relation)    {        if (!empty($this->with) && is_array($this->with)) {            foreach ($this->with as $key => $value) {                if (is_int($key)) {                    if ($relation == $value) {                        unset($this->with[$key]);                        break;                    }                } else {                    if ($relation == $key) {                        unset($this->with[$key]);                        break;                    }                }            }        }        return $this;    }    /**     * Bugungi sanadagi ma'lumotlarni ajratib oladi     * @param string $attribute bazadan qaysi attribute bo'yicha ajratib olish kerakligi     * @return $this     */    public function today(string $attribute = 'created_at')    {        $begin = strtotime('today');        $end = strtotime('tomorrow');        $attribute = $this->generateAttributeName($attribute);        $this->andWhere(['>=', $attribute, $begin])            ->andWhere(['<', $attribute, $end]);        return $this;    }    /**     * Bazadan shu sanagacha bo'lgan ma'lumotlarni ajratib olish     * @param $date int|string|null sana timestamp formatda     * @param $includeThisDay bool whether include given day     * @param string $attribute qaysi attribute bo'yicha ajratib olish kerakligi     */    public function toDate($date = null, string $attribute = 'created_at', bool $includeThisDay = true)    {        if ($date != null) {            $date = Yii::$app->formatter->asTimestamp($date);            $day = strtotime(date('Y-m-d', $date));            if ($includeThisDay) {                $time = strtotime('+1 day', $day);            } else {                $time = $day;            }            $attribute = $this->generateAttributeName($attribute);            $this->andWhere(['<', $attribute, $time]);            return $this;        }        return $this;    }    /**     * Bazadan aynan berilgan sanadagi ma'lumotlarni ajratib olish     * @param $date int|string sana timestamp formatda     * @param string $attribute qaysi attribute bo'yicha ajratib olish kerakligi     */    public function day($date = null, string $attribute = 'created_at')    {        if ($date != null) {            $date = Yii::$app->formatter->asTimestamp($date);            /** @var int Kunning boshlanishi */            $dayBegin = strtotime(date('Y-m-d', $date));            /** @var int Ertasi kunning boshlanishi */            $dayEnd = strtotime('+1 day', $dayBegin);            $attribute = $this->generateAttributeName($attribute);            return $this->andWhere(['>=', $attribute, $dayBegin])                ->andWhere(['<', $attribute, $dayEnd]);        }        return $this;    }    /**     * Berilgan oraliqdagi ma'lumotlarni saralab olish     * @param $from int|string Timestamp formatidagi sana     * @param $to int|string Timestamp formatidagi sana     * @param string $attribute     */    public function range($from, $to, string $attribute = 'created_at')    {        return $this->andWhere(['>=', $attribute, $from])            ->andWhere(['<', $attribute, $to]);    }    /**     * @param string $attribute     * @return $this     */    public function asc(string $attribute)    {        return $this->orderBy([$attribute => SORT_ASC]);    }    /**     * @param string $attribute     * @return $this     */    public function desc(string $attribute)    {        return $this->orderBy([$attribute => SORT_DESC]);    }    /**     * Berilgan sanalar oralig'i bo'yicha ma'lumotlarni filtrlash     * @param $value mixed text ko'rinishidagi sanalar oraligi, masalan: 01.11.2021 - 16.11.2021.     * Bunda ma'lumotlar 01.11.2021 00:00 dan 16.11.2021 23:59:59 gacha bo'lgan oraliqdagi ma'lumotlar kiradi     * @param string $attribute     * @param string|null $separator     * @return $this     */    public function dateRange($value, string $attribute = 'date', string $separator = null)    {        if (!empty($value)) {            if ($separator === null) {                $separator = DateRangePicker::SEPARATOR;            }            $dates = explode($separator, $value, 2);            if (count($dates) == 2) {                $begin = strtotime($dates[0]);                $end = strtotime('+1 day', strtotime($dates[1]));                $this->andWhere(['>=', $attribute, $begin])                    ->andWhere(['<', $attribute, $end]);            }        }        return $this;    }    /**     * @param $attribute string     * @param bool $isNull     * @return $this     */    public function null($attribute, bool $isNull = true)    {        if ($isNull) {            return $this->andWhere([$attribute => null]);        }        return $this->andWhere(['not', [$attribute => null]]);    }    /**     * @param $attribute string     * @return $this     */    public function notNull($attribute)    {        return $this->null($attribute, false);    }    /**     * @param $tags string|array a list of tag names for this dependency.     * For a single tag, you may specify it as a string.     * @param $duration int|true the number of seconds that query results can remain valid in cache.     * Use 0 to indicate that the cached data will never expire.     * Use a negative number to indicate that query cache should not be used.     * Use boolean `true` to indicate that [[Connection::queryCacheDuration]] should be used.     * Defaults to `true`.     * @return $this     * @see TagDependency     */    public function cacheWithTags($tags, $duration = true)    {        $this->cache($duration, new TagDependency(['tags' => $tags]));        return $this;    }}?>